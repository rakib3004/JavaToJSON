{
    "package": "org.apache.hadoop.mapred",
    "imports": [
        "java.io.File",
        "java.io.IOException",
        "java.lang.management.ManagementFactory",
        "java.lang.management.RuntimeMXBean",
        "java.lang.management.ThreadInfo",
        "java.lang.management.ThreadMXBean",
        "java.util.HashMap",
        "java.util.HashSet",
        "java.util.Map",
        "java.util.Set",
        "java.util.Collections",
        "java.util.concurrent.BlockingQueue",
        "java.util.concurrent.ConcurrentHashMap",
        "java.util.concurrent.ExecutorService",
        "java.util.concurrent.Future",
        "java.util.concurrent.LinkedBlockingQueue",
        "org.apache.hadoop.classification.VisibleForTesting",
        "org.apache.hadoop.fs.FSError",
        "org.apache.hadoop.fs.FileContext",
        "org.apache.hadoop.fs.FileStatus",
        "org.apache.hadoop.fs.FileSystem",
        "org.apache.hadoop.fs.Path",
        "org.apache.hadoop.fs.UnsupportedFileSystemException",
        "org.apache.hadoop.mapreduce.JobContext",
        "org.apache.hadoop.mapreduce.JobCounter",
        "org.apache.hadoop.mapreduce.MRConfig",
        "org.apache.hadoop.mapreduce.TaskID",
        "org.apache.hadoop.mapreduce.TypeConverter",
        "org.apache.hadoop.mapreduce.v2.api.records.TaskAttemptId",
        "org.apache.hadoop.mapreduce.v2.api.records.TaskType",
        "org.apache.hadoop.mapreduce.v2.app.AppContext",
        "org.apache.hadoop.mapreduce.v2.app.job.Job",
        "org.apache.hadoop.mapreduce.v2.app.job.event.JobCounterUpdateEvent",
        "org.apache.hadoop.mapreduce.v2.app.job.event.TaskAttemptContainerLaunchedEvent",
        "org.apache.hadoop.mapreduce.v2.app.job.event.TaskAttemptEvent",
        "org.apache.hadoop.mapreduce.v2.app.job.event.TaskAttemptEventType",
        "org.apache.hadoop.mapreduce.v2.app.launcher.ContainerLauncher",
        "org.apache.hadoop.mapreduce.v2.app.launcher.ContainerLauncherEvent",
        "org.apache.hadoop.mapreduce.v2.app.launcher.ContainerRemoteLaunchEvent",
        "org.apache.hadoop.service.AbstractService",
        "org.apache.hadoop.util.ExitUtil",
        "org.apache.hadoop.util.ShutdownHookManager",
        "org.apache.hadoop.util.StringUtils",
        "org.apache.hadoop.util.concurrent.HadoopExecutors",
        "org.apache.hadoop.yarn.api.ApplicationConstants.Environment",
        "org.apache.hadoop.yarn.exceptions.YarnRuntimeException",
        "org.apache.hadoop.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder",
        "org.slf4j.Logger",
        "org.slf4j.LoggerFactory"
    ],
    "classes": [
        {
            "name": "extends",
            "methods": [
                {
                    "name": "handle",
                    "args": [
                        "public",
                        "void"
                    ],
                    "body": [
                        "try {",
                        "eventQueue.put(event);",
                        "} catch (InterruptedException e) {",
                        "throw new YarnRuntimeException(e);  // FIXME? YarnRuntimeException is \"for runtime exceptions only\""
                    ]
                },
                {
                    "name": "setEncryptedSpillKey",
                    "args": [
                        "public",
                        "void"
                    ],
                    "body": [
                        "if (encryptedSpillKey != null) {",
                        "this.encryptedSpillKey = encryptedSpillKey;"
                    ]
                },
                {
                    "name": "run",
                    "args": [
                        "",
                        "",
                        "public",
                        "void"
                    ],
                    "body": [
                        "ContainerLauncherEvent event = null;",
                        "",
                        "// Collect locations of map outputs to give to reduces",
                        "final Map<TaskAttemptID, MapOutputFile> localMapFiles =",
                        "new HashMap<TaskAttemptID, MapOutputFile>();",
                        "",
                        "// _must_ either run subtasks sequentially or accept expense of new JVMs",
                        "// (i.e., fork()), else will get weird failures when maps try to create/",
                        "// write same dirname or filename:  no chdir() in Java",
                        "while (!Thread.currentThread().isInterrupted()) {",
                        "try {",
                        "event = eventQueue.take();",
                        "} catch (InterruptedException e) {  // mostly via T_KILL? JOB_KILL?",
                        "LOG.warn(\"Returning, interrupted : \" + e);",
                        "break;"
                    ]
                },
                {
                    "name": "run",
                    "args": [
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "",
                        "public",
                        "void"
                    ],
                    "body": [
                        "runTask(launchEv, localMapFiles);"
                    ]
                },
                {
                    "name": "RenamedMapOutputFile",
                    "args": [
                        "",
                        "",
                        "public"
                    ],
                    "body": [
                        "this.path = path;"
                    ]
                },
                {
                    "name": "getOutputFileForWriteInVolume",
                    "args": [
                        "",
                        "",
                        "public",
                        "Path"
                    ],
                    "body": [
                        "throw new UnsupportedOperationException();"
                    ]
                },
                {
                    "name": "getOutputIndexFileForWriteInVolume",
                    "args": [
                        "",
                        "",
                        "public",
                        "Path"
                    ],
                    "body": [
                        "throw new UnsupportedOperationException();"
                    ]
                }
            ]
        }
    ],
    "methods": [
        {
            "name": "handle",
            "args": [
                "public",
                "void"
            ],
            "body": [
                "try {",
                "eventQueue.put(event);",
                "} catch (InterruptedException e) {",
                "throw new YarnRuntimeException(e);  // FIXME? YarnRuntimeException is \"for runtime exceptions only\""
            ]
        },
        {
            "name": "setEncryptedSpillKey",
            "args": [
                "public",
                "void"
            ],
            "body": [
                "if (encryptedSpillKey != null) {",
                "this.encryptedSpillKey = encryptedSpillKey;"
            ]
        },
        {
            "name": "run",
            "args": [
                "",
                "",
                "public",
                "void"
            ],
            "body": [
                "ContainerLauncherEvent event = null;",
                "",
                "// Collect locations of map outputs to give to reduces",
                "final Map<TaskAttemptID, MapOutputFile> localMapFiles =",
                "new HashMap<TaskAttemptID, MapOutputFile>();",
                "",
                "// _must_ either run subtasks sequentially or accept expense of new JVMs",
                "// (i.e., fork()), else will get weird failures when maps try to create/",
                "// write same dirname or filename:  no chdir() in Java",
                "while (!Thread.currentThread().isInterrupted()) {",
                "try {",
                "event = eventQueue.take();",
                "} catch (InterruptedException e) {  // mostly via T_KILL? JOB_KILL?",
                "LOG.warn(\"Returning, interrupted : \" + e);",
                "break;"
            ]
        },
        {
            "name": "run",
            "args": [
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "public",
                "void"
            ],
            "body": [
                "runTask(launchEv, localMapFiles);"
            ]
        },
        {
            "name": "RenamedMapOutputFile",
            "args": [
                "",
                "",
                "public"
            ],
            "body": [
                "this.path = path;"
            ]
        },
        {
            "name": "getOutputFileForWriteInVolume",
            "args": [
                "",
                "",
                "public",
                "Path"
            ],
            "body": [
                "throw new UnsupportedOperationException();"
            ]
        },
        {
            "name": "getOutputIndexFileForWriteInVolume",
            "args": [
                "",
                "",
                "public",
                "Path"
            ],
            "body": [
                "throw new UnsupportedOperationException();"
            ]
        }
    ]
}